def username = ''
def email = ''

def imageName = "dyrtransportes-flask:${BRANCH_NAME.toLowerCase().replaceAll('/', '_')}"
def tag = ''
def tagComment = "Jenkins CI/CD Pipeline. Branch: ${BRANCH_NAME}. Build ID: ${BUILD_ID}. Build URL: ${BUILD_URL}"

def dockerImage
def dockerComposeFile = 'docker/docker-compose-dev.yaml'

def registry = 'http://localhost:5000'
// def registryCredentials = 'localhost-docker-registry'

def numberCommits = 5
def commitList = ''

pipeline {
    agent any

    options {
        disableConcurrentBuilds(abortPrevious: true)
        skipDefaultCheckout()
    }

    environment {
        GITHUB_REPO = 'Rad710/dyrtransportes_flask'
    }

    stages {
        stage('Checkout SCM') {
            steps {
                script {
                    echo "Cloning Repository..."

                    cleanWs()
                    checkout scm
                }
            }
        }

        stage('Prepare') {
            steps {
                script {
                    echo 'Preparing...'

                    echo 'env Variables'
                    echo "PATH is: $PATH"
                    echo "USER is: $USER"

                    sh 'printenv'
                    script {
                        params.each { param, value ->
                            print "Parameter: ${param}, Value: ${value}"
                        }
                    }

                    releasePattern = ~/release\/\d+\.\d+\.\d+$/

                    if (BRANCH_NAME ==~ releasePattern) {
                        imageName = 'dyrtransportes/backend/dev/dyrtransportes-flask'

                        tag = BRANCH_NAME.split('/').last() + ".${BUILD_ID}-dev"
                    }

                    if (BRANCH_NAME == 'main') {
                        imageName = 'dyrtransportes/backend/dev/dyrtransportes-flask'

                        tag = sh(returnStdout: true, script: 'git describe --tags --abbrev=0').trim()
                        tag = tag.split("\\.")[0..2].join(".")
                    }

                    if (BRANCH_NAME == 'develop') {
                        imageName = 'dyrtransportes/backend/dev/dyrtransportes-flask'

                        tag = "0.0.${BUILD_ID}-test"
                    }


                    username = sh(script: "git show -s --pretty=%an", returnStdout: true).trim()
                    email = sh(script: "git show -s --pretty=%ae", returnStdout: true).trim()
                    echo "Repo Author name: ${username}/email:${email}"

                    if (currentBuild.getBuildCauses()[0].shortDescription.contains("Started by user")) {
                        username = null
                        email = currentBuild.getBuildCauses()[0].userId
                    }
    
                    echo "Author: ${username}/${email}"

                    commitList = sh(returnStdout: true, script: "git log -${numberCommits} --format=\"%s\"").trim()
                    echo "List of Commits: ${commitList}"

                    sh 'git config --global user.name "jenkins"'
                    sh 'git config --global user.email "jenkins@jenkins.com"'
                }
            }
        }

        stage('Build Step') {
            steps {
                script {
                    echo "Building..."

                    sh """
                        rm .env
                        echo "DB_USERNAME = 'root'" >> .env
                        echo "DB_PASSWORD = 'root'" >> .env
                        echo "DB_HOST = 'dyrtransportes-mysql-dev'" >> .env
                        echo "DB_NAME = 'dyrtransportes'" >> .env
                    """

                    dockerImage = docker.build(imageName, "-f docker/Dockerfile.flask .")
                }
            }
        }

        stage('Test & pylint') {
            steps {
                echo 'Testing must be implemented...'
            }
        }

        stage('SonarQube Quality Gate') {
            steps {
                script {
                    echo 'Scanning...'

                    sh """
                        echo "sonar.projectKey=D-y-R-Transportes-Flask" >> sonar-project.properties
                        echo "sonar.python.version=3.10" >> sonar-project.properties
                    """

                    def scannerHome = tool 'SonarScanner'
                    withSonarQubeEnv("http://localhost:9000") {
                        sh "${scannerHome}/bin/sonar-scanner"
                    }
                }
            }
        }

        stage('Tag GIT Repo') {
            when {
                expression {
                    return !tag.isEmpty()
                }
            }
            steps {
                script {
                    echo "Tagging..."
                    echo "GIT tag: ${tag}. Tag comment: ${tagComment}"
                    withCredentials([usernamePassword(credentialsId: 'rad710-jenkins-github-app',
                        usernameVariable: 'GITHUB_APP',
                        passwordVariable: 'GITHUB_ACCESS_TOKEN')]) {  
                    
                        sh "git tag -a ${tag} -m \"${tagComment}\" "
                        sh "git push https://${GITHUB_APP}:${GITHUB_ACCESS_TOKEN}@github.com/${GITHUB_REPO}.git ${tag}"
                        sh "git tag -d ${tag}"
                    }
                }
            }
        }

        stage('Push Docker Registry') {
            when {
                expression {
                    return !tag.isEmpty()
                }
            }
            steps {
                script {
                    echo "Pushing..."
                    docker.withRegistry(registry) {
                        echo "Push Docker Image: ${imageName} with tag: ${tag}"
                        dockerImage.push("${tag}")
                        dockerImage.push("latest")
                    }
                }
            }
        }

        stage('Archive Artifact') {
            when {
                expression {
                    return !tag.isEmpty() && BRANCH_NAME != 'develop'
                }
            }

            steps {
                script {
                    echo "Archiving..."
                    // usar el docker compose para tener env de diferentes ambientes
                    sh "docker compose -f ${dockerComposeFile} up -d"
                    
                    dockerEnv = dockerComposeFile.replace('docker/docker-compose-', '')
                    dockerEnv = dockerEnv.replace('.yaml', '')
                    serviceName = "dyrtransportes-flask-" + dockerEnv
                    containerName = sh(script: "docker compose -f ${dockerComposeFile} ps -q ${serviceName}", 
                        returnStdout: true).trim() 
                    
                    sh "docker cp ${containerName}:/usr/share/nginx/html ./artifact"
                    sh "docker compose -f ${dockerComposeFile} down"

                    sh "tar -czvf ${serviceName}-${tag}.tar.gz ./artifact"

                    archiveArtifacts artifacts: "${serviceName}-${tag}.tar.gz",
                        allowEmptyArchive: true,
                        fingerprint: true,
                        onlyIfSuccessful: true
                }
            }
        }

        stage('Create GitHub Release') {
            when {
                expression {
                    return !tag.isEmpty() && BRANCH_NAME != 'develop'
                }
            }

            steps {
                script {
                    echo "Releasing..."
                    withCredentials([usernamePassword(credentialsId: 'rad710-jenkins-github-app',
                        usernameVariable: 'GITHUB_APP',
                        passwordVariable: 'GITHUB_ACCESS_TOKEN')]) {

                        try {
                            createRelease = sh(script: """
                                curl -s -X POST \
                                -w "%{http_code}" \
                                -H "Authorization: token ${GITHUB_ACCESS_TOKEN}" \
                                -H "Accept: application/vnd.github+json" \
                                -H "X-GitHub-Api-Version: 2022-11-28" \
                                https://api.github.com/repos/${GITHUB_REPO}/releases \
                                -d '{ "tag_name": "${tag}", \
                                    "target_commitish": "${BRANCH_NAME}", \
                                    "name": "${tag}", \
                                    "body": "${tagComment}", \
                                    "draft": false, \
                                    "prerelease": false, \
                                    "generate_release_notes": true}'
                            """, returnStdout: true).trim()

                            responseCode = createRelease.split('\n')[-1] as Integer
                            createRelease = createRelease.split(responseCode as String)[0]

                            echo "Create Release Respose: ${createRelease}"
                            echo "Response Code from GitHub Release: ${responseCode}"

                            responseJSON = readJSON(text: createRelease)
                            uploadUrl = responseJSON['upload_url'].replace('/assets{?name,label}', '')

                            echo "Upload URL: ${uploadUrl}"
                            sh """
                                curl -XPOST -H "Authorization: token ${GITHUB_ACCESS_TOKEN}" \
                                -H "Accept: application/vnd.github+json" \
                                -H "X-GitHub-Api-Version: 2022-11-28" \
                                -H "Content-Type:application/octet-stream" \
                                "${uploadUrl}/assets?name=${serviceName}-${tag}.tar.gz" \
                                --data-binary "@${serviceName}-${tag}.tar.gz"
                            """
                        } catch (e) {
                            echo "Error en crear GitHub Release: ${e}"
                        }
                    }
                }
            }
        }

        stage('Deploy Docker Host') {
            when {
                expression {
                    return !tag.isEmpty()
                }
            }
            steps {
                script {
                    echo "Deploying..."

                    dockerContext = "default"
                    echo "Deploy to Docker Host in ${dockerContext}"

                    try {
                        sh "docker --context ${dockerContext} compose -f ${dockerComposeFile} down"
                    } catch (e) {
                        echo "First time running docker compose!"
                    }

                    sh "docker --context ${dockerContext} compose -f ${dockerComposeFile} pull"
                    sh "docker --context ${dockerContext} compose -f ${dockerComposeFile} up -d"
                }
            }
        }
    }
    post {
        always {
            script {
                echo 'Post stage cleaning...'

                try {
                    sh "docker rmi -f \$(docker images -q ${imageName})"
                } catch (e) {
                    echo 'No docker image to delete. Or failure when deleting!'
                }

                notificationMessage = tagComment + " Result: ${currentBuild.currentResult}."
                if (!tag.isEmpty()) {
                    notificationMessage += " Push to Docker Registry with tag: ${tag}."
                }

                blameData = [:]
                myTags = ['blame_data':['author': username, 'email': email, 'cause': currentBuild.getBuildCauses()[0].shortDescription]]

                def customMeasurementFields = [:]
                customMeasurementFields['blame_data'] = blameData
                
                echo "Custom measurements: ${customMeasurementFields}. Custom tags: ${myTags}"


                // mail to: "rolmedro@gmail.com",
                //     subject: tagComment,
                //     body : notificationMessage

                // withSonarQubeEnv("http://localhost:9000") {
                //     influxDbPublisher(selectedTarget: 'influxdb', 
                //         customDataMap: customMeasurementFields, 
                //         customDataMapTags: myTags)
                // }

                // userId = slackUserIdFromEmail(email)
                // if (currentBuild.currentResult != 'SUCCESS') {
                //     notificationColor = 'danger'
                // }  else {
                //     notificationColor = 'good'
                // }
                // slackSend(channel: "@${userId}", color: "${notificationColor}", message: "${notificationMessage}", notifyCommitters: true)

                cleanWs()
            }
        }
    }
}